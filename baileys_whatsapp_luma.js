#!/usr/bin/env node
/**
 * üî• LUMA BUSINESS PRO - BAILEYS WHATSAPP INTEGRATION
 * ==================================================
 * WhatsApp automatique 100% GRATUIT avec Baileys
 * Pas de Meta Business, pas d'API payante !
 * ==================================================
 * FICHIER POUR CURSOR : baileys_whatsapp_luma.js
 */

const { makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys')
const { Boom } = require('@hapi/boom')
const express = require('express')
const axios = require('axios')
const fs = require('fs')
const path = require('path')
const qrcode = require('qrcode-terminal')

// üîó Int√©gration Notion
const NotionIntegration = require('./modules/notion_integration')

// Configuration
const CONFIG = {
    // LUMA Service
    lumaWebhookUrl: 'http://localhost:5001/webhook/whatsapp',
    
    // Business Info
    businessName: 'Harley Vape',
    businessHours: { start: 9, end: 18 },
    
    // Baileys Config
    authFolder: './baileys_auth',
    logLevel: 'info',
    
    // Auto-response
    autoResponseEnabled: true,
    responseDelay: 2000 // 2 secondes pour humaniser
}

// Templates WhatsApp Lulu (int√©gr√©s directement)
const LUMA_TEMPLATES = {
    welcome_new_client: "Bonjour {name} ! üëã\nMerci de contacter Harley Vape !\n\nJe suis LUMA, l'assistante digitale d'Anne-Sophie. Comment puis-je vous aider aujourd'hui ? üòä\n\nüõí Commandes\nüì¶ Suivi livraison\n‚ùì Questions produits\n\nR√©pondez simplement !",
    
    urgent_support: "üö® URGENT - Pris en charge !\n\nBonjour {name}, je comprends l'urgence de votre situation.\n\nJe transmets imm√©diatement √† Anne-Sophie qui vous recontacte sous 30 minutes maximum.\n\nVotre demande urgente est notre priorit√© absolue ! üíô",
    
    order_inquiry: "üì¶ Commande en cours !\n\nBonjour {name}, je v√©rifie votre commande imm√©diatement.\n\nVotre demande est prise en compte et notre √©quipe vous recontacte tr√®s rapidement avec toutes les infos ! üòä\n\nAutre chose pour vous aider ?",
    
    after_hours: "üåô Harley Vape - Hors horaires\n\nBonsoir {name} !\n\nIl est {time} et notre √©quipe est en repos bien m√©rit√© üò¥\n\nVotre message est enregistr√© et nous vous r√©pondons d√®s demain matin (9h-18h).\n\nBonne soir√©e ! üåü",
    
    general_response: "Salut {name} ! üòä\n\nMerci pour votre message ! Je suis LUMA, l'assistante d'Anne-Sophie pour Harley Vape.\n\nComment puis-je vous aider ?\n\nüõí Commandes et produits\nüìû Contact direct\n‚ùì Questions diverses\n\nJe suis l√† pour vous ! üíô"
}

class BaileysLumaService {
    constructor() {
        this.sock = null
        this.clientContexts = new Map()
        this.isReady = false
        
        // Cr√©er dossier auth si inexistant
        if (!fs.existsSync(CONFIG.authFolder)) {
            fs.mkdirSync(CONFIG.authFolder, { recursive: true })
        }
    }

    async start() {
        console.log('üöÄ LUMA Baileys WhatsApp Service - D√©marrage...')
        
        try {
            // √âtat d'authentification multi-device
            const { state, saveCreds } = await useMultiFileAuthState(CONFIG.authFolder)
            
            // Cr√©er socket WhatsApp
            this.sock = makeWASocket({
                auth: state,
                browser: ['LUMA Business Pro', 'Desktop', '1.0.0'],
                markOnlineOnConnect: true
            })
            
            // Gestionnaires d'√©v√©nements
            this.setupEventHandlers(saveCreds)
            
            console.log('üì± En attente de connexion WhatsApp...')
            console.log('üëÜ Scannez le QR code avec votre WhatsApp !')
            
        } catch (error) {
            console.error('üí• Erreur d√©marrage Baileys:', error)
        }
    }

    setupEventHandlers(saveCreds) {
        // Gestion connexion
        this.sock.ev.on('connection.update', (update) => {
            const { connection, lastDisconnect, qr } = update
            
            if (qr) {
                console.log('üì± Nouveau QR Code g√©n√©r√© ! Scannez avec WhatsApp')
                console.log('üîç Affichage du QR Code dans le terminal...')
                qrcode.generate(qr, { small: true })
                console.log('üëÜ Scannez le QR code ci-dessus avec votre WhatsApp !')
            }
            
            if (connection === 'close') {
                const shouldReconnect = (lastDisconnect?.error instanceof Boom)?.output?.statusCode !== DisconnectReason.loggedOut
                
                console.log('üîå Connexion ferm√©e:', lastDisconnect?.error, ', reconnexion:', shouldReconnect)
                
                if (shouldReconnect) {
                    setTimeout(() => this.start(), 3000)
                }
            } else if (connection === 'open') {
                console.log('‚úÖ WhatsApp connect√© avec succ√®s !')
                console.log('üéâ LUMA peut maintenant r√©pondre automatiquement !')
                this.isReady = true
            }
        })

        // Sauvegarde credentials
        this.sock.ev.on('creds.update', saveCreds)

        // R√âCEPTION MESSAGES - C≈íUR DU SYST√àME
        this.sock.ev.on('messages.upsert', async ({ messages }) => {
            for (const message of messages) {
                await this.handleIncomingMessage(message)
            }
        })

        // Gestion pr√©sence (optionnel)
        this.sock.ev.on('presence.update', ({ id, presences }) => {
            console.log('üëÄ Pr√©sence update:', id, Object.keys(presences))
        })
    }

    async handleIncomingMessage(message) {
        try {
            // Ignorer messages de LUMA elle-m√™me
            if (message.key.fromMe) return
            
            // Extraire infos message
            const messageInfo = this.extractMessageInfo(message)
            if (!messageInfo) return
            
            console.log(`üì± Message re√ßu de ${messageInfo.phone}: ${messageInfo.text}`)
            
            // Traitement LUMA
            await this.processWithLuma(messageInfo)
            
        } catch (error) {
            console.error('‚ùå Erreur traitement message:', error)
        }
    }

    extractMessageInfo(message) {
        const phone = message.key.remoteJid
        const messageType = Object.keys(message.message || {})[0]
        
        let text = ''
        let contactName = phone.split('@')[0] // Fallback
        
        // Extraction texte selon type
        if (messageType === 'conversation') {
            text = message.message.conversation
        } else if (messageType === 'extendedTextMessage') {
            text = message.message.extendedTextMessage.text
        } else if (messageType === 'imageMessage' && message.message.imageMessage.caption) {
            text = message.message.imageMessage.caption
        } else {
            console.log('üìé Type de message non support√©:', messageType)
            return null
        }
        
        // Essayer d'obtenir le nom du contact
        if (message.pushName) {
            contactName = message.pushName
        }
        
        return {
            phone: phone,
            text: text.trim(),
            contactName: contactName,
            messageId: message.key.id,
            timestamp: message.messageTimestamp || Date.now()
        }
    }

    async processWithLuma(messageInfo) {
        const startTime = Date.now()
        
        try {
            // 1. Analyser message et contexte
            const context = this.getClientContext(messageInfo.phone, messageInfo.contactName)
            const intent = this.analyzeIntent(messageInfo.text)
            
            // 2. G√©n√©rer r√©ponse LUMA
            const lumaResponse = this.generateLumaResponse(messageInfo, context, intent)
            
            // 3. Optionnel: Appeler service LUMA Python pour traitement avanc√©
            let enhancedResponse = lumaResponse
            if (CONFIG.lumaWebhookUrl) {
                try {
                    const webhookResponse = await axios.post(CONFIG.lumaWebhookUrl, {
                        from: messageInfo.phone,
                        message: messageInfo.text,
                        contact_name: messageInfo.contactName,
                        baileys_source: true
                    }, { timeout: 10000 })
                    
                    if (webhookResponse.data && webhookResponse.data.luma_response) {
                        enhancedResponse = webhookResponse.data.luma_response
                        console.log('üß† R√©ponse LUMA Python utilis√©e')
                    }
                } catch (webhookError) {
                    console.log('‚ö†Ô∏è Service LUMA Python non disponible, utilisation templates locaux')
                }
            }
            
            // 4. D√©lai humanis√©
            if (CONFIG.responseDelay > 0) {
                await this.sleep(CONFIG.responseDelay)
            }
            
            // 5. Envoyer r√©ponse
            await this.sendMessage(messageInfo.phone, enhancedResponse)
            
            // 6. üîó Int√©gration Notion automatique
            const processingTime = Date.now() - startTime
            await this.integrateWithNotion(messageInfo, enhancedResponse, processingTime)
            
            // 7. Log interaction
            this.logInteraction(messageInfo, enhancedResponse, intent)
            
        } catch (error) {
            console.error('‚ùå Erreur processWithLuma:', error)
            
            // R√©ponse de fallback
            const fallbackResponse = `Bonjour ${messageInfo.contactName} ! Merci pour votre message. Notre √©quipe Harley Vape vous r√©pond tr√®s rapidement ! üòä`
            await this.sendMessage(messageInfo.phone, fallbackResponse)
            
            // Int√©gration Notion m√™me en cas d'erreur
            const processingTime = Date.now() - startTime
            await this.integrateWithNotion(messageInfo, fallbackResponse, processingTime)
        }
    }

    analyzeIntent(text) {
        const textLower = text.toLowerCase()
        
        const intents = {
            urgent: ['urgent', 'probl√®me', 'help', 'aide', 'bug', 'erreur'],
            order: ['commande', 'order', 'suivi', 'tracking', 'livraison'],
            product: ['produit', 'product', 'prix', 'price', 'stock'],
            greeting: ['bonjour', 'hello', 'salut', 'hi', 'bonsoir'],
            thanks: ['merci', 'thank', 'parfait', 'super', 'g√©nial']
        }
        
        for (const [intent, keywords] of Object.entries(intents)) {
            if (keywords.some(keyword => textLower.includes(keyword))) {
                return intent
            }
        }
        
        return 'general'
    }

    generateLumaResponse(messageInfo, context, intent) {
        const now = new Date()
        const hour = now.getHours()
        const isBusinessHours = hour >= CONFIG.businessHours.start && hour <= CONFIG.businessHours.end
        
        const variables = {
            name: messageInfo.contactName,
            time: now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' })
        }
        
        let templateKey = 'general_response'
        
        // S√©lection template selon contexte
        if (!isBusinessHours) {
            templateKey = 'after_hours'
        } else if (intent === 'urgent') {
            templateKey = 'urgent_support'
        } else if (intent === 'order') {
            templateKey = 'order_inquiry'
        } else if (context.interactionCount === 0) {
            templateKey = 'welcome_new_client'
        }
        
        // G√©n√©ration r√©ponse
        let response = LUMA_TEMPLATES[templateKey] || LUMA_TEMPLATES.general_response
        
        // Remplacement variables
        for (const [key, value] of Object.entries(variables)) {
            response = response.replace(new RegExp(`{${key}}`, 'g'), value)
        }
        
        return response
    }

    getClientContext(phone, name) {
        if (!this.clientContexts.has(phone)) {
            this.clientContexts.set(phone, {
                phone: phone,
                name: name,
                interactionCount: 0,
                lastInteraction: null,
                notes: ''
            })
        }
        
        const context = this.clientContexts.get(phone)
        context.interactionCount++
        context.lastInteraction = new Date()
        
        return context
    }

    async sendMessage(phone, text) {
        try {
            if (!this.isReady) {
                console.log('‚ö†Ô∏è WhatsApp pas encore pr√™t, message en attente...')
                return
            }
            
            await this.sock.sendMessage(phone, { text: text })
            console.log(`üì§ R√©ponse envoy√©e √† ${phone}: ${text.substring(0, 50)}...`)
            
        } catch (error) {
            console.error('‚ùå Erreur envoi message:', error)
        }
    }

    logInteraction(messageInfo, response, intent) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            phone: messageInfo.phone.substring(0, 8) + '****', // Privacy
            contact_name: messageInfo.contactName,
            message_in: messageInfo.text.substring(0, 100),
            message_out: response.substring(0, 100),
            intent: intent,
            source: 'baileys'
        }
        
        console.log('üìä Interaction:', JSON.stringify(logEntry))
        
        // Optionnel: Sauvegarder dans fichier
        const logFile = path.join(__dirname, 'luma_interactions.log')
        fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\n')
    }

    createLogger() {
        return {
            level: CONFIG.logLevel,
            child: () => this.createLogger(),
            error: (...args) => console.log('[ERROR]', ...args),
            warn: (...args) => console.log('[WARN]', ...args),
            info: (...args) => console.log('[INFO]', ...args),
            debug: (...args) => console.log('[DEBUG]', ...args),
            trace: (...args) => console.log('[TRACE]', ...args),
            log: (level, ...args) => {
                if (level === 'error' || level === 'warn') {
                    console.log(`[${level.toUpperCase()}]`, ...args)
                }
            }
        }
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms))
    }

    // M√©thodes utilitaires
    async getProfilePicture(phone) {
        try {
            const profilePic = await this.sock.profilePictureUrl(phone, 'image')
            return profilePic
        } catch {
            return null
        }
    }

    async markAsRead(phone, messageId) {
        try {
            await this.sock.readMessages([{ remoteJid: phone, id: messageId }])
        } catch (error) {
            console.log('‚ö†Ô∏è Impossible de marquer comme lu:', error.message)
        }
    }

    // üîó Int√©gration automatique avec Notion
    async integrateWithNotion(messageInfo, responseText, processingTime) {
        try {
            // Initialiser l'int√©gration Notion
            const notionIntegration = new NotionIntegration()
            
            // Logger automatiquement dans Notion
            const notionResult = await notionIntegration.logToNotion(messageInfo, responseText, processingTime)
            
            if (notionResult.success) {
                console.log(`üéâ Int√©gration Notion r√©ussie pour ${messageInfo.contactName}`)
                console.log(`‚è±Ô∏è Temps total: ${notionResult.totalTime}ms`)
            } else {
                console.error('‚ùå Erreur int√©gration Notion:', notionResult.error)
            }
            
        } catch (error) {
            console.error('‚ùå Erreur int√©gration Notion:', error)
            // Ne pas bloquer le processus principal en cas d'erreur Notion
        }
    }
}

// Interface HTTP pour monitoring (optionnel)
class LumaMonitoringServer {
    constructor(baileysService) {
        this.baileys = baileysService
        this.app = express()
        this.app.use(express.json())
        
        this.setupRoutes()
    }

    setupRoutes() {
        // Status LUMA
        this.app.get('/status', (req, res) => {
            res.json({
                service: 'LUMA Baileys WhatsApp',
                status: this.baileys.isReady ? 'connected' : 'connecting',
                clients: this.baileys.clientContexts.size,
                timestamp: new Date().toISOString()
            })
        })

        // Envoyer message manuel (pour tests)
        this.app.post('/send', async (req, res) => {
            try {
                const { phone, message } = req.body
                if (!phone || !message) {
                    return res.status(400).json({ error: 'phone et message requis' })
                }
                
                await this.baileys.sendMessage(phone, message)
                res.json({ success: true, message: 'Message envoy√©' })
                
            } catch (error) {
                res.status(500).json({ error: error.message })
            }
        })

        // Statistiques
        this.app.get('/stats', (req, res) => {
            const contexts = Array.from(this.baileys.clientContexts.values())
            res.json({
                total_clients: contexts.length,
                interactions_today: contexts.reduce((sum, ctx) => sum + ctx.interactionCount, 0),
                active_conversations: contexts.filter(ctx => 
                    ctx.lastInteraction && 
                    Date.now() - ctx.lastInteraction.getTime() < 24 * 60 * 60 * 1000
                ).length
            })
        })
    }

    start(port = 3001) {
        this.app.listen(port, () => {
            console.log(`üìä Monitoring LUMA disponible sur http://localhost:${port}`)
            console.log(`üìä Status: http://localhost:${port}/status`)
        })
    }
}

// D√âMARRAGE PRINCIPAL
async function main() {
    console.log('üî• LUMA BUSINESS PRO - BAILEYS WHATSAPP (GRATUIT)')
    console.log('üíô R√©ponses automatiques clients sans Meta Business !')
    console.log('=' + '='.repeat(50))
    
    try {
        // V√©rifier d√©pendances
        console.log('üì¶ V√©rification d√©pendances...')
        
        // D√©marrer service Baileys
        const lumaService = new BaileysLumaService()
        await lumaService.start()
        
        // D√©marrer monitoring (optionnel)
        const monitoring = new LumaMonitoringServer(lumaService)
        monitoring.start(3001)
        
        console.log('\nüéâ LUMA BAILEYS OP√âRATIONNEL !')
        console.log('üì± Scannez le QR code avec WhatsApp Business Harley Vape')
        console.log('‚ö° R√©ponses automatiques activ√©es !')
        
        // Gestion arr√™t propre
        process.on('SIGINT', () => {
            console.log('\nüëã Arr√™t LUMA Baileys...')
            process.exit(0)
        })
        
    } catch (error) {
        console.error('üí• Erreur d√©marrage:', error)
        process.exit(1)
    }
}

// Gestion erreurs non captur√©es
process.on('unhandledRejection', (error) => {
    console.error('üí• Erreur non g√©r√©e:', error)
})

process.on('uncaughtException', (error) => {
    console.error('üí• Exception non captur√©e:', error)
    process.exit(1)
})

// Lancement si fichier principal
if (require.main === module) {
    main()
}

module.exports = { BaileysLumaService, LumaMonitoringServer } 